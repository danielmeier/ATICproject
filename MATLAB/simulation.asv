clc
clear all
close all

% add packages
addpath(genpath('C:/Users/daniel/Documents/GitHub/ATICproject/MATLAB/packages'))

%% Load parameters
run('parameters')
omega = logspace(-4,3,250);

%% Linearize normalized car plant

[A_P,B_P,C_P,D_P] = linmod('P_car',[0,0,0,0],0);
P_car = ss(A_P,B_P,C_P,D_P);

figure
P_car_f = frd(P_car,omega);

subplot(2,2,[1 3])
step(P_car,0.2);

subplot(2,2,2)           
loglog(abs(P_car_f(1,1)));
axis([min(omega),max(omega),1e-5,10])
grid
legend('rho <- alpha')
xlabel('Frequency [rad/sec]')
ylabel('Magnitude')

r2d = 180/pi;

subplot(2,2,4)
semilogx(r2d*unwrap(angle(P_car_f(1,1))))
grid
xlabel('Frequency [rad/sec]')
ylabel('Phase [deg]')
title('Nominal model')


%% Perturbation weights

run('define_weights.m')

%     ---------------- interconnection structure ------------

%    The interconnection structure has the following i/o
%    connections.   The numbers corrrespond to the port
%    numbers on the simulink block diagram.  The letters
%    correspond to:
%                            ________
%                            |       |
%      Delta inputs:  z  <---|       |<--- v:  Delta output
%                            |       |
%      cost/errors:   e  <---|   P   |<--- w:  exogenous inputs
%                            |       |
%      measurements:  y  <---|       |<--- u:  control actuation
%                            |_______|
%
%
%                       Outputs     Inputs
%
%    Delta1 (rho)         z1          v1
%
%    rho tracking err     e2          w2  rho noise
%    alpha act penalty    e3          w3  rho reference
%                                     w4  rho disturbance
%
%    rho reference        y4          u5  alpha command
%    rho measurement      y5
%
%    The controller will have 1 input and 1 output.  Note
%    the positive feedback is assumed in the implementation
%    of the controller.

sys_P_car = linmod('model_car');
A_P = sys_P_car.a;
B_P = sys_P_car.b;
C_P = sys_P_car.c;
D_P = sys_P_car.d;

%[A_P,B_P,C_P,D_P] = linmod('model_car');
P = ss(A_P,B_P,C_P,D_P);

%    Create indices for each block.

Iz = [1:1]';
Ie = [2:3]';
Iy = [4:5]';

Iv = [1:1]';
Iw = [2:4]';
Iu = [5:5]';

%    define dimensions for each

nz = length(Iz);
nv = length(Iv);
ne = length(Ie);
nw = length(Iw);
nmeas = length(Iy);
nctrl = length(Iu);


% ----------------  nominal design -----------------------

Pnomdesign = P([Ie;Iy],[Iw;Iu]);    % select [e;y] <- [w;u]

Pnomdesign = minreal(Pnomdesign);   % remove unobservable/uncontrollable
                                    % states.
				     
[Knom,Gnom,gamma,info] = hinfsyn(Pnomdesign,nmeas,nctrl,...
    'METHOD','ric',...   % Riccati solution
	'DISPLAY','on',...   % verbose
	'TOLGAM',0.1);       % gamma tolerance
			    
%  Check this design and see if we are happy with this as the best
%  possible nominal performance.  At this stage we should retune
%  the weights depending of frequency responses, step response,
%  etc.

clp_eig = eig(Gnom);
fprintf('Max real part weighted closed loop eig = %g',...
          max(real(clp_eig)));
if max(real(clp_eig)) > -eps,
  fprintf('  UNSTABLE !\n\n');
else
  fprintf('  (stable)\n\n');
end

analyze_controller(Pnomdesign,Knom,nctrl,nmeas,omega,'Nominal Design')




% H2-Controller solving the LMI equations, using SPD
A   = A_P;
Bw  = B_P(:,Iw);
Bu  = B_P(:,Iu);
Ce  = C_P(Ie,:);
Cy  = C_P(Iy,:);
Dew = D_P(Ie,Iw);
Dyw = D_P(Iy,Iw);
Deu = D_P(Ie,Iu);
Dyu = D_P(Iy,Iu);

n = size(A,1);

cvx_begin sdp
    cvx_solver sedumi
    
    variable X(n,n) symmetric;
    variable Y(n,n) symmetric;
    variable W(length(Ie),length(Ie)) symmetric;
    variable Ah(n,n);
    variable Bh(n,length(Iy));
    variable Ch(length(Iu),n);
    variable gamma_2lmi
    
    minimize gamma_2lmi;
    subject to
        trace(W) < gamma_2lmi;
              
        0.5*(...
        [W, Ce*X + Deu*Ch, Ce;
            X*Ce'+Ch'*Deu', X, eye(n,n);
            Ce', eye(n,n),Y]+...
        [W, Ce*X + Deu*Ch, Ce;
            X*Ce'+Ch'*Deu', X, eye(n,n);
            Ce', eye(n,n),Y]') > 0; % 0.5*(X+X') to make it symmetric (rounding errors...)
        
        0.5*(...
        [A*X+Bu*Ch+X*A'+Ch'*Bu', A+Ah', Bw;
            A'+Ah, Y*A'+A'*Y+Bh*Cy+Cy'*Bh', Y*Bw+Bh*Dyw;
            Bw',Bw'*Y+Dyw'*Bh', -eye(length(Iw),length(Iw))]+...
        [A*X+Bu*Ch+X*A'+Ch'*Bu', A+Ah', Bw;
            A'+Ah, Y*A'+A'*Y+Bh*Cy+Cy'*Bh', Y*Bw+Bh*Dyw;
            Bw',Bw'*Y+Dyw'*Bh', -eye(length(Iw),length(Iw))]') < 0;  

cvx_end

MNt = eye(n)-X*Y;
[U_MNt,S_MNt,V_MNt] = svd(MNt);

sSmn    = sqrt(diag(S_MNt));
isSmn   = 1./sSmn;

M  = U_MNt * diag(sSmn);
N  = V_MNt * diag(sSmn);

iM = diag(isSmn)*U_MNt';         % calculate inverses 
iN = diag(isSmn)*V_MNt';

Ck = Ch*iM';
Bk = iN*Bh;
Ak = iN*(Ah-N*Bk*Cy*X-Y*Bu*Ck*M'-Y*A*X)*iM';
Dk = zeros(length(Iu),length(Iy));
 
K_2lmi = ss(Ak,Bk,Ck,Dk);

analyze_controller(Pnomdesign,Knom,nctrl,nmeas,omega,'Nominal Design')







% H2_controller using h2syn()
P_test  = ss(A,[Bw,Bu], [Ce;Cy],[Dew, Deu;Dyw,Dyu]); 
nmeas   = 2;
ncon    = 1;
[K_2syn, Gnom_2syn, gamma_2syn, info_2syn] = h2syn(P_test, nmeas, ncon);

























